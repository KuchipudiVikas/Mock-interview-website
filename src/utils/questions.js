export const python = {
    'level': 'intermediate',
    'questions': [{ 'question': '<h3>Apart from the security aspect, what are the reasons behind making strings immutable in Java?</h3>', 'answer': '<article class="ibpage-article">\n<p>A String is made immutable due to the following reasons:</p><ul><li>\n<strong>String Pool:</strong> Designers of Java were aware of the fact that String data type is going to be majorly used by the programmers and developers. Thus, they wanted optimization from the beginning. They came up with the notion of using the String pool (a storage area in Java heap) to store the String literals. They intended to decrease the temporary String object with the help of sharing. An immutable class is needed to facilitate sharing. The sharing of the mutable structures between two unknown parties is not possible. Thus, immutable Java String helps in executing the concept of String Pool.</li></ul><figure class="image image_resized" style="width:75%;"><img class="lazy-elem" data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/335/original/string_pool.png?1618995310"/></figure><ul>\n<li>\n<a href="https://www.interviewbit.com/multithreading-interview-questions/" rel="noopener noreferrer" target="_blank"><strong>Multithreading</strong></a><strong>:</strong> The safety of threads regarding the String objects is an important aspect in Java. No external synchronization is required if the String objects are immutable. Thus, a cleaner code can be written for sharing the String objects across different threads. The complex process of concurrency is facilitated by this method.</li>\n<li>\n<a href="https://www.interviewbit.com/java-collections-interview-questions/" rel="noopener noreferrer" target="_blank"><strong>Collections</strong></a><strong>:</strong> In the case of Hashtables and HashMaps, keys are String objects. If the String objects are not immutable, then it can get modified during the period when it resides in the HashMaps. Consequently, the retrieval of the desired data is not possible. Such changing states pose a lot of risks. Therefore, it is quite safe to make the string immutable.</li>\n</ul>\n</article>' }, { 'question': '<h3>What is a singleton class in Java? And How to implement a singleton class?</h3>', 'answer': '<article class="ibpage-article">\n<p>Singleton classes are those classes, whose objects are created only once. And with only that object the class members can be accessed.\xa0</p><p><strong>Understand this with the help of an example-:</strong></p><p>Consider the water jug in the office and if every employee wants that water then they will not create a new water jug for drinking water. They will use the existing one with their own reference as a glass. So programmatically it should be implemented as -</p><pre><code class="language-java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WaterJug</span></span>{\n   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> waterQuantity = <span class="hljs-number">500</span>;\n   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">WaterJug</span><span class="hljs-params">()</span></span>{}\n   <span class="hljs-keyword">private</span> WaterJug object = <span class="hljs-keyword">null</span>;\n   \n   <span class="hljs-comment">// Method to provide the service of Giving Water.</span>\n   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWater</span><span class="hljs-params">(<span class="hljs-keyword">int</span> quantity)</span></span>{\n       waterQuantity -= quantity;\n       <span class="hljs-keyword">return</span> quantity;\n   }\n   <span class="hljs-comment">// Method to return the object to the user.</span>\n   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Waterjug <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>{\n       <span class="hljs-comment">// Will Create a new object if the object is not already created and return the object.</span>\n       <span class="hljs-keyword">if</span>(object == <span class="hljs-keyword">null</span>){\n           object = <span class="hljs-keyword">new</span> WaterJug();\n       }\n       <span class="hljs-keyword">return</span> object;\n   }\n}</code></pre><p>In the above class, the Constructor is private so we cannot create the object of the class. But we can get the object by calling the method <strong>getInstance()</strong>. And the getInstance is static so it can be called without creating the object. And it returns the object. Now with that object, we can call <strong>getWater() </strong>to get the water.</p><pre><code class="language-java hljs">Waterjug glass1 = WaterJug.getInstance();\nglass1.getWater(<span class="hljs-number">1</span>);</code></pre><p>We can get the single object using this getInstance(). And it is static, so it is a thread-safe singleton class. Although there are many ways to create a thread-safe singleton class. So thread-safe classes can also be:</p><ul>\n<li>When singletons are written with double-checked locking, they can be thread-safe.</li>\n<li>We can use static singletons that are initialized during class loading. Like we did in the above example.</li>\n<li>But the most straightforward way to create a thread-safe singleton is to use Java enums.</li>\n</ul>\n</article>' }, { 'question': '<h3>Which of the below generates a compile-time error? State the reason. </h3>', 'answer': '<article class="ibpage-article">\n<ol>\n<li><strong>int[] n1 = new int[0];</strong></li>\n<li><strong>boolean[] n2 = new boolean[-200];</strong></li>\n<li><strong>double[] n3 = new double[2241423798];</strong></li>\n<li><strong>char[] ch = new char[20];</strong></li>\n</ol><p>We get a compile-time error in line 3. The error we will get in Line 3 is - <strong>integer number too large</strong>. It is because the array requires size as an integer. And Integer takes 4 Bytes in the memory. And the number (<strong>2241423798</strong>) is beyond the capacity of the integer. The maximum array size we can declare is - (<strong>2147483647</strong>).</p><p>Because the array requires the size in integer, none of the lines (1, 2, and 4) will give a compile-time error. The program will compile fine. But we get the runtime exception in line 2. The exception is - <strong>NegativeArraySizeException</strong>.\xa0</p><p>Here what will happen is - At the time when JVM will allocate the required memory during runtime then it will find that the size is negative. And the array size can’t be negative. So the JVM will throw the exception.</p>\n</article>' }, { 'question': '<h3>How would you differentiate between a String, StringBuffer, and a StringBuilder?</h3>', 'answer': '<article class="ibpage-article">\n<ul>\n<li>\n<strong>Storage area:</strong> In string, the String pool serves as the storage area. For StringBuilder and StringBuffer, heap memory is the storage area.</li>\n<li>\n<strong>Mutability:</strong> A String is immutable, whereas both the StringBuilder and StringBuffer are mutable.</li>\n<li>\n<strong>Efficiency:</strong> It is quite slow to work with a String. However, StringBuilder is the fastest in performing operations. The speed of a StringBuffer is more than a String and less than a StringBuilder. (For example appending a character is fastest in StringBuilder and very slow in String because a new memory is required for the new String with appended character.)</li>\n<li>\n<strong>Thread-safe:</strong> In the case of a threaded environment, StringBuilder and StringBuffer are used whereas a String is not used. However, StringBuilder is suitable for an environment with a single thread, and a StringBuffer is suitable for multiple threads.<br/><strong>Syntax:</strong>\n</li>\n</ul><pre><code class="language-java hljs"><span class="hljs-comment">// String</span>\nString first = <span class="hljs-string">"InterviewBit"</span>;\nString second = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"InterviewBit"</span>);\n<span class="hljs-comment">// StringBuffer</span>\nStringBuffer third = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">"InterviewBit"</span>);\n<span class="hljs-comment">// StringBuilder</span>\nStringBuilder fourth = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"InterviewBit"</span>);</code></pre>\n</article>' }, { 'question': '<h3>Using relevant properties highlight the differences between interfaces and abstract classes.</h3>', 'answer': '<article class="ibpage-article">\n<ul>\n<li>\n<strong>Availability of methods:</strong> Only abstract methods are available in interfaces, whereas non-abstract methods can be present along with abstract methods in abstract classes.</li>\n<li>\n<strong>Variable types</strong>: Static and final variables can only be declared in the case of interfaces, whereas abstract classes can also have non-static and non-final variables.</li>\n<li>\n<strong>Inheritance: </strong>Multiple inheritances are facilitated by interfaces, whereas abstract classes do not promote multiple inheritances.</li>\n<li>\n<strong>Data member accessibility:</strong> By default, the class data members of interfaces are of the public- type. Conversely, the class members for an abstract class can be protected or private also.</li>\n<li>\n<strong>Implementation:</strong> With the help of an abstract class, the implementation of an interface is easily possible. However, the converse is not true;</li>\n</ul><p><strong>Abstract class example:</strong></p><pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Athlete</span> </span>{\n<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span>;\n}</code></pre><p><strong>Interface example:</strong></p><pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Walkable</span> </span>{\n<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span>;\n}</code></pre>\n</article>' }, { 'question': '<h3>Is this program giving a compile-time error? If Yes then state the reason and number of errors it will give. If not then state the reason.</h3>', 'answer': '<article class="ibpage-article">\n<pre><code class="language-java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterviewBit</span></span>{\n<span class="hljs-number">2.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span>;\n<span class="hljs-number">3.</span> }\n<span class="hljs-number">4.</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScalarAcademy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InterviewBit</span></span>{\n<span class="hljs-number">5.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span>{\n<span class="hljs-number">6.</span>        System.out.println(<span class="hljs-string">"Welcome to Scalar Academy By InterviewBit"</span>);\n<span class="hljs-number">7.</span>    }\n<span class="hljs-number">8.</span> }\n<span class="hljs-number">9.</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScalarTopics</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ScalarAcademy</span></span>{\n<span class="hljs-number">10.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span>{\n<span class="hljs-number">11.</span>        System.out.println(<span class="hljs-string">"Welcome to Scalar Topics By Scalar Academy"</span>);\n<span class="hljs-number">12.</span>    }\n<span class="hljs-number">13.</span> }\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>{\n\t<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n \t    InterviewBit ib = <span class="hljs-keyword">new</span> ScalarTopics();\n \t    ib.printMessage();\n\t}\n}</code></pre><p>The above program will give a compile-time error. The compiler will throw 2 errors in this.</p><ul>\n<li>\n<strong>[Illegal Combination of modifiers: abstract and final]</strong> at line 1.</li>\n<li>\n<strong>[Cannot inherit from final ‘InterviewBit’]</strong> at line 4.</li>\n</ul><p>It is because abstract classes are incomplete classes that need to be inherited for making their concrete classes. And on the other hand, the final keywords in class are used for avoiding inheritance. So these combinations are not allowed in java.</p>\n</article>' }, { 'question': '<h3>What is a Comparator in java?</h3>', 'answer': '<article class="ibpage-article">\n<p>Consider the example where we have an ArrayList of employees like( EId, Ename, Salary), etc. Now if we want to sort this list of employees based on the names of employees. Then that is not possible to sort using the Collections.sort() method. We need to provide something to the sort() function depending on what values we have to perform sorting. Then in that case a comparator is used.</p><p>Comparator is the interface in java that contains the compare method. And by overloading the compare method, we can define that on what basis we need to compare the values.\xa0</p>\n</article>' }, { 'question': '<h3>In Java, static as well as private method overriding is possible. Comment on the statement.</h3>', 'answer': '<article class="ibpage-article">\n<p>The statement in the context is completely False. The static methods have no relevance with the objects, and these methods are of the class level. In the case of a child class, a static method with a method signature exactly like that of the parent class can exist without even throwing any compilation error.</p><p>The phenomenon mentioned here is popularly known as method hiding, and overriding is certainly not possible. Private method overriding is unimaginable because the visibility of the private method is restricted to the parent class only. As a result, only hiding can be facilitated and not overriding.</p>\n</article>' }, { 'question': '<h3>What makes a HashSet different from a TreeSet?</h3>', 'answer': '<article class="ibpage-article">\n<p>Although both HashSet and TreeSet are not synchronized and ensure that duplicates are not present, there are certain properties that distinguish a HashSet from a TreeSet.</p><ul>\n<li>\n<strong>Implementation:</strong> For a HashSet, the hash table is utilized for storing the elements in an unordered manner. However, TreeSet makes use of the red-black tree to store the elements in a sorted manner.</li>\n<li>\n<strong>Complexity/ Performance:</strong> For adding, retrieving, and deleting elements, the time amortized complexity is O(1) for a HashSet. The time complexity for performing the same operations is a bit higher for TreeSet and is equal to O(log n). Overall, the performance of HashSet is faster in comparison to TreeSet.</li>\n<li>\n<strong>Methods: </strong>hashCode() and equals() are the methods utilized by HashSet for making comparisons between the objects. Conversely, compareTo() and compare() methods are utilized by TreeSet to facilitate object comparisons.</li>\n<li>\n<strong>Objects type:</strong> Heterogeneous and null objects can be stored with the help of HashSet. In the case of a TreeSet, runtime exception occurs while inserting heterogeneous objects or null objects.</li>\n</ul>\n</article>' }, { 'question': '<h3>Why is the character array preferred over string for storing confidential information?</h3>', 'answer': '<article class="ibpage-article">\n<p>In Java, a string is basically immutable i.e. it cannot be modified. After its declaration, it continues to stay in the string pool as long as it is not removed in the form of garbage. In other words, a string resides in the heap section of the memory for an unregulated and unspecified time interval after string value processing is executed.</p><p>As a result, vital information can be stolen for pursuing harmful activities by hackers if a memory dump is illegally accessed by them. Such risks can be eliminated by using mutable objects or structures like character arrays for storing any variable. After the work of the character array variable is done, the variable can be configured to blank at the same instant. Consequently, it helps in saving heap memory and also gives no chance to the hackers to extract vital data.</p>\n</article>' }, { 'question': '<h3>What do we get in the JDK file?</h3>', 'answer': '<article class="ibpage-article">\n<ul>\n<li>\n<strong>JDK</strong>- For making java programs, we need some tools that are provided by JDK (Java Development Kit). JDK is the package that contains various tools, Compiler, Java Runtime Environment, etc.</li>\n<li>\n<strong>JRE </strong>- \xa0To execute the java program we need an environment. (Java Runtime Environment) JRE contains a library of Java classes + \xa0JVM. <strong>What are JAVA Classes?</strong> \xa0It contains some predefined methods that help Java programs to use that feature, build and execute. <i><strong>For example</strong></i> - there is a system class in java that contains the print-stream method, and with the help of this, we can print something on the console.</li>\n<li>\n<strong>JVM</strong> - (Java Virtual Machine) JVM \xa0is a part of JRE that executes the Java program at the end. \xa0Actually, it is part of JRE, but it is software that converts bytecode into machine-executable code to execute on hardware.</li>\n</ul><figure class="image image_resized" style="width:50%;"><img class="lazy-elem" data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/021/original/jdk_jre_jvm.png?1648813873"/></figure>\n</article>' }, { 'question': '<h3>What are the differences between JVM, JRE and JDK in Java?</h3>', 'answer': '<article class="ibpage-article">\n<figure class="table"><table>\n<thead><tr>\n<th>Criteria</th>\n<th>JDK\xa0</th>\n<th>JRE</th>\n<th>JVM</th>\n</tr></thead>\n<tbody>\n<tr>\n<th>Abbreviation</th>\n<td>Java Development Kit</td>\n<td>Java Runtime Environment</td>\n<td>Java Virtual Machine</td>\n</tr>\n<tr>\n<th>Definition</th>\n<td>JDK is a complete software development kit for developing Java applications. It comprises JRE, JavaDoc, compiler, debuggers, etc.</td>\n<td>JRE is a software package providing Java class libraries, JVM and all the required components to run the Java applications.</td>\n<td>JVM is a platform-dependent, abstract machine comprising of 3 specifications - document describing the JVM implementation requirements, computer program meeting the JVM requirements and instance object for executing the Java byte code and provide the runtime environment for execution.</td>\n</tr>\n<tr>\n<th>Main Purpose</th>\n<td>JDK is mainly used for code development and execution.</td>\n<td>JRE is mainly used for environment creation to execute the code.</td>\n<td>JVM provides specifications for all the implementations to JRE.</td>\n</tr>\n<tr>\n<th>Tools provided</th>\n<td>JDK provides tools like compiler, debuggers, etc for code development</td>\n<td>JRE provides libraries and classes required by JVM to run the program.</td>\n<td>JVM does not include any tools, but instead, it provides the specification for implementation.</td>\n</tr>\n<tr>\n<th>Summary</th>\n<td>JDK = (JRE) + Development tools</td>\n<td>JRE = (JVM) + Libraries to execute the application</td>\n<td>JVM = Runtime environment to execute Java byte code.</td>\n</tr>\n</tbody>\n</table></figure>\n</article>' }, { 'question': '<h3>What are the differences between HashMap and HashTable in Java?</h3>', 'answer': '<article class="ibpage-article">\n<figure class="table"><table>\n<thead><tr>\n<th>HashMap</th>\n<th>HashTable</th>\n</tr></thead>\n<tbody>\n<tr>\n<td>HashMap is not synchronized thereby making it better for non-threaded applications.</td>\n<td>HashTable is synchronized and hence it is suitable for threaded applications.</td>\n</tr>\n<tr>\n<td>Allows only one null key but any number of null in the values.</td>\n<td>This does not allow null in both keys or values.</td>\n</tr>\n<tr>\n<td>Supports order of insertion by making use of its subclass LinkedHashMap.</td>\n<td>Order of insertion is not guaranteed in HashTable.</td>\n</tr>\n</tbody>\n</table></figure>\n</article>' }, { 'question': '<h3>What is the importance of reflection in Java?</h3>', 'answer': '<article class="ibpage-article">\n<ul>\n<li>The term <code>reflection</code> is used for describing the inspection capability of a code on other code either of itself or of its system and modify it during runtime.</li>\n<li>Consider an example where we have an object of unknown type and we have a method ‘fooBar()’ which we need to call on the object. The static typing system of Java doesn\'t allow this method invocation unless the type of the object is known beforehand. This can be achieved using reflection which allows the code to scan the object and identify if it has any method called “fooBar()” and only then call the method if needed.</li>\n</ul><pre><code class="language-java hljs">Method methodOfFoo = fooObject.getClass().getMethod(<span class="hljs-string">"fooBar"</span>, <span class="hljs-keyword">null</span>);\nmethodOfFoo.invoke(fooObject, <span class="hljs-keyword">null</span>);</code></pre><ul>\n<li>Using reflection has its own cons:<ul>\n<li>Speed — Method invocations due to reflection are about three times slower than the direct method calls.</li>\n<li>Type safety — When a method is invoked via its reference wrongly using reflection, invocation fails at runtime as it is not detected at compile/load time.</li>\n<li>Traceability — Whenever a reflective method fails, it is very difficult to find the root cause of this failure due to a huge stack trace. One has to deep dive into the invoke() and proxy() method logs to identify the root cause.</li>\n</ul>\n</li>\n<li>Hence, it is advisable to follow solutions that don\'t involve reflection and use this method as a last resort.</li>\n</ul>\n</article>' }, { 'question': '<h3>What are the different ways of threads usage?</h3>', 'answer': '<article class="ibpage-article">\n<ul><li>We can define and implement a thread in java using two ways:<ul><li><strong>Extending the Thread class</strong></li></ul>\n</li></ul><pre><code class="language-java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterviewBitThreadExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>{  \n   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>{  \n       System.out.println(<span class="hljs-string">"Thread runs..."</span>);  \n   }  \n   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>{  \n       InterviewBitThreadExample ib = <span class="hljs-keyword">new</span> InterviewBitThreadExample();  \n       ib.start();  \n   }  \n}</code></pre><ul><li><strong>Implementing the Runnable interface</strong></li></ul><pre><code class="language-java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterviewBitThreadExample</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>{  \n   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>{  \n       System.out.println(<span class="hljs-string">"Thread runs..."</span>);  \n   }  \n   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>{  \n       Thread ib = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> InterviewBitThreadExample());\xa0\n       ib.start();  \n   }  \n}</code></pre><ul>\n<li>Implementing a thread using the method of Runnable interface is more preferred and advantageous as Java does not have support for multiple inheritances of classes.</li>\n<li>\n<code>start()</code> method is used for creating a separate call stack for the thread execution. Once the call stack is created, JVM calls the <code>run()</code> method for executing the thread in that call stack.</li>\n</ul>\n</article>' }, { 'question': '<h3>What are the different types of Thread Priorities in Java? And what is the default priority of a thread assigned by JVM?</h3>', 'answer': '<article class="ibpage-article">\n<p>There are a total of 3 different types of priority available in Java.\xa0</p><p><strong>MIN_PRIORITY:</strong> It has an integer value assigned with 1.<br/><strong>MAX_PRIORITY:</strong> It has an integer value assigned with 10.<br/><strong>NORM_PRIORITY: </strong>It has an integer value assigned with 5.</p><p>In Java, Thread with MAX_PRIORITY gets the first chance to execute. But the default priority for any thread is NORM_PRIORITY assigned by JVM.\xa0</p>\n</article>' }, { 'question': '<h3>What is the difference between the program and the process?</h3>', 'answer': '<article class="ibpage-article">\n<ul>\n<li>A program can be defined as a line of code written in order to accomplish a particular task. Whereas the process can be defined as the programs which are under execution.\xa0</li>\n<li>A program doesn\'t execute directly by the CPU. First, the resources are allocated to the program and when it is ready for execution then it is a process.</li>\n</ul>\n</article>' }, { 'question': '<h3>What is the difference between the ‘throw’ and ‘throws’ keyword in java?</h3>', 'answer': '<article class="ibpage-article">\n<ul>\n<li>The ‘<strong>throw</strong>’ keyword is used to manually throw the exception to the calling method.</li>\n<li>And the ‘<strong>throws</strong>’ keyword is used in the function definition to inform the calling method that this method throws the exception. So if you are calling, then you have to handle the exception.</li>\n</ul><p><strong>Example -\xa0</strong></p><pre><code class="language-java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{\n   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">testExceptionDivide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> ArithmeticException</span>{\n       <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span> || b == <span class="hljs-number">0</span>)\n           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException();\n       <span class="hljs-keyword">return</span> a/b;\n   }\n   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{\n       <span class="hljs-keyword">try</span>{\n           testExceptionDivide(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);\n       }\n       <span class="hljs-keyword">catch</span>(ArithmeticException e){\n           <span class="hljs-comment">//Handle the exception</span>\n       }\n   }\n}</code></pre><p>Here in the above snippet, the method testExceptionDivide throws an exception. So if the main method is calling it then it must have handled the exception. Otherwise, the main method can also throw the exception to JVM.</p><p>And the method testExceptionDivide \'throws’ the exception based on the condition.</p>\n</article>' }, { 'question': '<h3>What are the differences between constructor and method of a class in Java?</h3>', 'answer': '<article class="ibpage-article">\n<figure class="table"><table>\n<thead><tr>\n<th>Constructor</th>\n<th>Method</th>\n</tr></thead>\n<tbody>\n<tr>\n<td>Constructor is used for initializing the object state.</td>\n<td>Method is used for exposing the object\'s behavior.</td>\n</tr>\n<tr>\n<td>Constructor has no return type.</td>\n<td>Method should have a return type. Even if it does not return anything, return type is void.</td>\n</tr>\n<tr>\n<td>Constructor gets invoked implicitly.</td>\n<td>Method has to be invoked on the object explicitly.</td>\n</tr>\n<tr>\n<td>If the constructor is not defined, then a default constructor is provided by the java compiler.</td>\n<td>If a method is not defined, then the compiler does not provide it.</td>\n</tr>\n<tr>\n<td>The constructor name should be equal to the class name.</td>\n<td>The name of the method can have any name or have a class name too.</td>\n</tr>\n<tr>\n<td>A constructor cannot be marked as final because whenever a class is inherited, the constructors are not inherited. Hence, marking it final doesn\'t make sense. Java throws compilation error saying - <code>modifier final not allowed here</code>\n</td>\n<td>A method can be defined as final but it cannot be overridden in its subclasses.</td>\n</tr>\n<tr>\n<td>Final variable instantiations are possible inside a constructor and the scope of this applies to the whole class and its objects.</td>\n<td>A final variable if initialised inside a method ensures that the variable cant be changed only within the scope of that method.</td>\n</tr>\n</tbody>\n</table></figure>\n</article>' }, { 'question': '<h3>Identify the output of the below java program and  Justify your answer.</h3>', 'answer': '<article class="ibpage-article">\n<pre><code class="language-java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>{\n    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{\n        Scaler s = <span class="hljs-keyword">new</span> Scaler(<span class="hljs-number">5</span>);\n    }\n}\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterviewBit</span></span>{\n    InterviewBit(){\n        System.out.println(<span class="hljs-string">" Welcome to InterviewBit "</span>);\n    }\n}\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scaler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InterviewBit</span></span>{\n    Scaler(){\n        System.out.println(<span class="hljs-string">" Welcome to Scaler Academy "</span>);\n    }\n    Scaler(<span class="hljs-keyword">int</span> x){\n        <span class="hljs-keyword">this</span>();\n        <span class="hljs-keyword">super</span>();\n        System.out.println(<span class="hljs-string">" Welcome to Scaler Academy 2"</span>);\n    }\n}</code></pre><p>The above code will throw the compilation error. It is because the <strong>super()</strong> is used to call the parent class constructor. But there is the condition that super() must be the first statement in the block. Now in this case, if we replace <strong>this()</strong> with <strong>super()</strong> then also it will throw the compilation error. Because this() also has to be the first statement in the block. So in conclusion, we can say that we cannot use <strong>this()</strong> and <strong>super()</strong> keywords in the same block.</p>\n</article>' }, { 'question': '<h3> Java works as “pass by value” or “pass by reference” phenomenon?</h3>', 'answer': '<article class="ibpage-article">\n<p>Java always works as a “pass by value”. There is nothing called a “pass by reference” in Java. However, when the object is passed in any method, the address of the value is passed due to the nature of object handling in Java. When an object is passed, a copy of the reference is created by Java and that is passed to the method. The objects point to the same memory location. 2 cases might happen inside the method:</p><ul><li>\n<strong>Case 1: </strong>When the object is pointed to another location: In this case, the changes made to that object do not get reflected the original object before it was passed to the method as the reference points to another location.</li></ul><p>For example:</p><pre><code class="language-java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterviewBitTest</span></span>{\n   <span class="hljs-keyword">int</span> num;\n   InterviewBitTest(<span class="hljs-keyword">int</span> x){ \n       num = x; \n   }\n   InterviewBitTest(){ \n       num = <span class="hljs-number">0</span>; \n   }\n}\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span> </span>{\n   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>\n   </span>{\n       <span class="hljs-comment">//create a reference</span>\n       InterviewBitTest ibTestObj = <span class="hljs-keyword">new</span> InterviewBitTest(<span class="hljs-number">20</span>);\n       <span class="hljs-comment">//Pass the reference to updateObject Method</span>\n       updateObject(ibTestObj);\n       <span class="hljs-comment">//After the updateObject is executed, check for the value of num in the object.</span>\n       System.out.println(ibTestObj.num);\n   }\n   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateObject</span><span class="hljs-params">(InterviewBitTest ibObj)</span>\n   </span>{\n       <span class="hljs-comment">// Point the object to new reference</span>\n       ibObj = <span class="hljs-keyword">new</span> InterviewBitTest();\n       <span class="hljs-comment">// Update the value </span>\n       ibObj.num = <span class="hljs-number">50</span>;\n   }\n}\nOutput:\n<span class="hljs-number">20</span></code></pre><ul><li>\n<strong>Case 2:</strong> When object references are not modified: In this case, since we have the copy of reference the main object pointing to the same memory location, any changes in the content of the object get reflected in the original object.</li></ul><p>For example:</p><pre><code class="language-java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterviewBitTest</span></span>{\n   <span class="hljs-keyword">int</span> num;\n   InterviewBitTest(<span class="hljs-keyword">int</span> x){\xa0\n       num = x;\xa0\n   }\n   InterviewBitTest(){\xa0\n       num = <span class="hljs-number">0</span>;\xa0\n   }\n}\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Driver</span></span>{\n   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>\n   </span>{\n       <span class="hljs-comment">//create a reference</span>\n       InterviewBitTest ibTestObj = <span class="hljs-keyword">new</span> InterviewBitTest(<span class="hljs-number">20</span>);\n       <span class="hljs-comment">//Pass the reference to updateObject Method</span>\n       updateObject(ibTestObj);\n       <span class="hljs-comment">//After the updateObject is executed, check for the value of num in the object.</span>\n       System.out.println(ibTestObj.num);\n   }\n   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateObject</span><span class="hljs-params">(InterviewBitTest ibObj)</span>\n   </span>{\n       <span class="hljs-comment">// no changes are made to point the ibObj to new location</span>\n       <span class="hljs-comment">// Update the value of num</span>\n       ibObj.num = <span class="hljs-number">50</span>;\n   }\n}\nOutput:\n<span class="hljs-number">50</span></code></pre>\n</article>' }, { 'question': '<h3>What is the ‘IS-A ‘ relationship in OOPs java?</h3>', 'answer': '<article class="ibpage-article">\n<p>‘IS-A’ relationship is another name for inheritance. When we inherit the base class from the derived class, then it forms a relationship between the classes. So that relationship is termed an ‘IS-A’ Relationship.</p><p><strong>Example </strong>- Consider a Television (Typical CRT TV). Now another Smart TV \xa0that is inherited from television class. So we can say that the Smart iv is also a TV. Because CRT TV things can also be done in the Smart TV.</p><figure class="image image_resized" style="width:75%;"><img class="lazy-elem" data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/039/original/IS-A_relationship_in_OOPs_java.png?1648817219"/></figure><p>So here ‘IS-A’ Relationship formed. <strong>[ SmartTV ‘IS-A’ TV ]</strong>.</p>\n</article>' }, { 'question': '<h3>Which among String or String Buffer should be preferred when there are lot of updates required to be done in the data?</h3>', 'answer': '<article class="ibpage-article">\n<p>StringBuffer is mutable and dynamic in nature whereas String is immutable. Every updation / modification of String creates a new String thereby overloading the string pool with unnecessary objects. Hence, in the cases of a lot of updates, it is always preferred to use StringBuffer as it will reduce the overhead of the creation of multiple String objects in the string pool.</p>\n</article>' }, { 'question': '<h3>How to not allow serialization of attributes of a class in Java?</h3>', 'answer': '<article class="ibpage-article">\n<ul><li>In order to achieve this, the attribute can be declared along with the usage of <code>transient</code> keyword as shown below:</li></ul><pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterviewBitExample</span> </span>{ \n\n   <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> String someInfo; \n   <span class="hljs-keyword">private</span> String name;\n   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;\n   <span class="hljs-comment">// :</span>\n   <span class="hljs-comment">// Getters setters</span>\n   <span class="hljs-comment">// :</span>\n} </code></pre><ul><li>In the above example, all the fields except <code>someInfo</code> can be serialized.</li></ul>\n</article>' }, { 'question': '<h3>What happens if the static modifier is not included in the main method signature in Java?</h3>', 'answer': '<article class="ibpage-article">\n<p>There wouldn\'t be any compilation error. But then the program is run, since the JVM cant map the main method signature, the code throws “NoSuchMethodError” error at the runtime.</p>\n</article>' }, { 'question': '<h3>Consider the below program, identify the output, and also state the reason for that.</h3>', 'answer': '<article class="ibpage-article">\n<pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>{\n<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{\n System.out.println(<span class="hljs-string">" Hello. Main Method. "</span>);\n}\n<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] args)</span> </span>{\n System.out.println(<span class="hljs-string">" Hello. Main Method2. "</span>);\n}\n}</code></pre><p>The output of the above program will be <strong>Hello. Main Method</strong>. This is because JVM will always call the main method based on the definition it already has. Doesn\'t matter how many main methods we overload it will only execute one main method based on its declaration in JVM.</p>\n</article>' }, { 'question': '<h3>Can we make the main() thread a daemon thread?</h3>', 'answer': '<article class="ibpage-article">\n<p>In java multithreading, the main() threads are always non-daemon threads. And there is no way we can change the nature of the non-daemon thread to the daemon thread.</p>\n</article>' }, { 'question': '<h3>What happens if there are multiple main methods inside one class in Java?</h3>', 'answer': '<article class="ibpage-article">\n<p>The program can\'t compile as the compiler says that the method has been already defined inside the class.</p>\n</article>' }, { 'question': '<h3>What do you understand by Object Cloning and how do you achieve it in Java?</h3>', 'answer': '<article class="ibpage-article">\n<ul><li>It is the process of creating an exact copy of any object. In order to support this, a java class has to implement the Cloneable interface of java.lang package and override the clone() method provided by the Object class the syntax of which is:</li></ul><pre><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>{\n <span class="hljs-keyword">return</span> (Object)<span class="hljs-keyword">super</span>.clone();\n}</code></pre><ul><li>In case the Cloneable interface is not implemented and just the method is overridden, it results in CloneNotSupportedException in Java.</li></ul>\n</article>' }, { 'question': '<h3>How does an exception propagate in the code?</h3>', 'answer': '<article class="ibpage-article">\n<p>When an exception occurs, first it searches to locate the matching catch block. In case, the matching catch block is located, then that block would be executed. Else, the exception propagates through the method call stack and goes into the caller method where the process of matching the catch block is performed. This propagation happens until the matching catch block is found. If the match is not found, then the program gets terminated in the main method.</p><figure class="image image_resized" style="width:75%;"><img class="lazy-elem" data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/345/original/java_stack.jpg?1619019436"/></figure>\n</article>' }, { 'question': "<h3>How do exceptions affect the program if it doesn't handle them?</h3>", 'answer': '<article class="ibpage-article">\n<p>Exceptions are runtime errors. Suppose we are making an android application with java. And it all works fine but there is an exceptional case when the application tries to get the file from storage and the file doesn’t exist (This is the case of exception in java). And if this case is not handled properly then the application will crash. This will be a bad experience for users. \xa0This is the type of error that cannot be controlled by the programmer. But programmers can take some steps to avoid this so that the application won’t crash. The proper action can be taken at this step.</p>\n</article>' }, { 'question': '<h3>Is it mandatory for a catch block to be followed after a try block?</h3>', 'answer': '<article class="ibpage-article">\n<p>No, it is not necessary for a catch block to be present after a try block. - A try block should be followed either by a catch block or by a finally block. If the exceptions likelihood is more, then they should be declared using the throws clause of the method.</p>\n</article>' }, { 'question': '<h3>Will the finally block get executed when the return statement is written at the end of try block and catch block as shown below?</h3>', 'answer': '<article class="ibpage-article">\n<pre><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">someMethod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>{\n   <span class="hljs-keyword">try</span>{\n       <span class="hljs-comment">//some statement</span>\n       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;\n   }<span class="hljs-keyword">catch</span>(Exception e){\n       <span class="hljs-comment">//some statement</span>\n       <span class="hljs-keyword">return</span> <span class="hljs-number">999</span>;\n   }<span class="hljs-keyword">finally</span>{\n       <span class="hljs-comment">//finally block statements</span>\n   }\n}</code></pre><p>finally block will be executed irrespective of the exception or not. The only case where finally block is not executed is when it encounters ‘System.exit()’ method anywhere in try/catch block.</p>\n</article>' }, { 'question': '<h3>Can you call a constructor of a class inside the another constructor?</h3>', 'answer': '<article class="ibpage-article">\n<p>Yes, the concept can be termed as constructor chaining and can be achieved using <code>this()</code>.</p><figure class="image image_resized" style="width:75%;"><img class="lazy-elem" data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/346/original/constructor_chaining_in_Java.jpg?1619071959"/></figure>\n</article>' }, { 'question': '<h3>Contiguous memory locations are usually used for storing actual values in an array but not in ArrayList. Explain.</h3>', 'answer': '<article class="ibpage-article">\n<p>In the case of ArrayList, data storing in the form of primitive data types (like int, float, etc.) is not possible. The data members/objects present in the ArrayList have references to the objects which are located at various sites in the memory. Thus, storing of actual objects or non-primitive data types (like Integer, Double, etc.) takes place in various memory locations.</p><figure class="image image_resized" style="width:75%;"><img class="lazy-elem" data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/328/original/sorting_of_objects_in_arraylist.png?1618934804"/></figure><p>However, the same does not apply to the arrays. Object or primitive type values can be stored in arrays in contiguous memory locations, hence every element does not require any reference to the next element.</p><figure class="image image_resized" style="width:75%;"><img class="lazy-elem" data-src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/329/original/sorting_of_values_in_array.png?1618934847"/></figure>\n</article>' }, { 'question': '<h3>Why does the java array index start with 0?</h3>', 'answer': '<article class="ibpage-article">\n<p>It is because the 0 index array avoids the extra arithmetic operation to calculate the memory address.</p><p>Example - Consider the array and assume each element takes 4-byte memory space. Then the address will be like this -</p><figure class="image image_resized" style="width:75%;"><img class="lazy-elem" data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/024/original/4-byte_memory_space.png?1648814139"/></figure><p>Now if we want to access index 4. Then internally java calculates the address using the formula-</p><p><strong>[Base Address + (index * no_of_bytes)]</strong>. So according to this. The starting address of the index 4 will be - <strong>[100 + (4*4)] = 116</strong>. And exactly that\'s what the address is calculated.\xa0<br/>Now consider the same with 1 index Array -</p><figure class="image image_resized" style="width:75%;"><img class="lazy-elem" data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/025/original/4-byte_memory_space_with_1_index_array.png?1648814164"/></figure><p>Now if we apply the same formula here. Then we get - <strong>116</strong> as the starting address of the 4th index. Which is wrong. Then we need to apply formula - [<strong>Base Address + ((index-1) * no_of_bytes)]</strong>.</p><p>And for calculating this, an extra arithmetic operation has to be performed. And consider the case where millions of addresses need to be calculated, this causes complexity. So to avoid this, ) the index array is supported by java.</p>\n</article>' }, { 'question': '<h3>Why is the remove method faster in the linked list than in an array?</h3>', 'answer': '<article class="ibpage-article">\n<p>In the linked list, we only need to adjust the references when we want to delete the element from either end or the front of the linked list. But in the array, indexes are used. So to manage proper indexing, we need to adjust the values from the array So this adjustment of value is costlier than the adjustment of references.</p><p><strong>Example</strong> - To Delete from the front of the linked list, internally the references adjustments happened like this.</p><figure class="image image_resized" style="width:75%;"><img class="lazy-elem" data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/027/original/Delete_from_the_front_of_the_linked_list.png?1648814824"/></figure><p>The only thing that will change is that the head pointer will point to the head’s next node. And delete the previous node. That is the constant time operation.</p><p>Whereas in the ArrayList, internally it should work like this-</p><figure class="image image_resized" style="width:75%;"><img class="lazy-elem" data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/028/original/ArrayList.png?1648814946"/></figure><p>For deletion of the first element, all the next element has to move to one place ahead. So this copying value takes time. So that is the reason why removing in ArrayList is slower than LinkedList.</p>\n</article>' }, { 'question': '<h3>How many overloaded add() and addAll() methods are available in the List interface? Describe the need and uses.</h3>', 'answer': '<article class="ibpage-article">\n<p>There are a total of 4 overloaded methods for add() and addAll() methods available in List Interface. The below table states the description of all.</p><figure class="table"><table>\n<thead><tr>\n<th>Return Type</th>\n<th>Method Description</th>\n</tr></thead>\n<tbody>\n<tr>\n<th>boolean</th>\n<td>\n<strong>add(Element e)</strong>: This method is used for adding the element at the end of the List. The Datatype of the element is of any type it has been initially assigned with. It returns the boolean indicating successfully inserted or not.</td>\n</tr>\n<tr>\n<th>void</th>\n<td>\n<strong>add(int index, Element e)</strong>: This method is the overloaded version of add() method. In this, along with the element, the index is also passed to the method for the specific index the value needs to be inserted.\xa0</td>\n</tr>\n<tr>\n<th>boolean</th>\n<td>\n<strong>addAll(Collection &lt;extends ? Element &gt; c)</strong>: This method helps to add all elements at the end of collections from the list received in the parameter. It contains an iterator that helps to iterate the list and add the elements to the collection.</td>\n</tr>\n<tr>\n<th>boolean</th>\n<td>\n<strong>addAll(int index, Collection &lt;extends ? Element &gt; c)</strong>: This is the overloaded method for addAll() method. In this along with the list, we can pass the specified index from which the list elements need to be added.</td>\n</tr>\n</tbody>\n</table></figure>\n</article>' }, { 'question': '<h3>How does the size of ArrayList grow dynamically? And also state how it is implemented internally.</h3>', 'answer': '<article class="ibpage-article">\n<p>ArrayList is implemented in such a way that it can grow dynamically. We don\'t need to specify the size of ArrayList. For adding the values in it, the methodology it uses is -</p><p>1. Consider initially that there are 2 elements in the ArrayList. <strong>[2, 3]</strong>.</p><figure class="image image_resized" style="width:50%;"><img class="lazy-elem" data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/030/original/step_1.png?1648815057"/></figure><p>2. If we need to add the element into this. Then internally what will happen is-</p><ul><li>ArrayList will allocate the new ArrayList of Size (current size + half of the current size). And add the old elements into the new. Old - [2, 3], \xa0 \xa0New - [2, 3, null, null].</li></ul><figure class="image image_resized" style="width:50%;"><img class="lazy-elem" data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/038/original/step_2a.png?1648817166"/></figure><ul><li>Then the new value will be inserted into it. [2, 3, 4, null]. And for the next time, the extra space will be available for the value to be inserted.</li></ul><figure class="image image_resized" style="width:50%;"><img class="lazy-elem" data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/031/original/step_2_b.png?1648815222"/></figure><p>3. This process continues and the time taken to perform all of these is considered as the amortized constant time.\xa0</p><p>This is how the ArrayList grows dynamically. And when we delete any entry from the ArrayList then the following steps are performed -</p><p>1. It searches for the element index in the array. Searching takes some time. Typically it’s O(n) because it needs to search for the element in the entire array.</p><figure class="image image_resized" style="width:50%;"><img class="lazy-elem" data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/034/original/step_3-a.png?1648815295"/></figure><p>2. After searching the element, it needs to shift the element from the right side to fill the index.</p><figure class="image image_resized" style="width:50%;"><img class="lazy-elem" data-src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/035/original/Step_3-b.png?1648815333"/></figure><p>So this is how the elements are deleted from the ArrayList internally. Similarly, the search operations are also implemented internally as defined in removing elements from the list (searching for elements to delete).</p>\n</article>' }]
}